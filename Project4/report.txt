Παππάς Απόστολος 2109 apopappas@inf.uth.gr
Ματζώρος Χρήστος Κωνσταντίνος 2169 cmatzoros@inf.uth.gr
Γιαννούκος Τριαντάφυλλος Ανάργυρος 2232 tgiannoukos@inf.uth.gr


Σχετικά με τον αλγόριθμο C-LOOK:

	Ο αλγόριθμος C-LOOK εξυπηρετεί τις αιτήσεις με αυξανόμενη σειρά κυλίνδρων, ξεκινώντας από την αίτηση με το μικρότερο 
αριθμό κυλίνδρου. Μόλις εξυπηρετήσει την αίτηση με το μεγαλύτερο αριθμό κυλίνδρου, επιστρέφει το βραχίονα στην αίτηση
με το μικρότερο αριθμό κυλίνδρου και επαναλαμβάνει στην ίδια διαδικασία.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Οι αλλαγές και προσθήκες που κάναμε στον κώδικα ήταν στις συναρτήσεις elevator_add_req_fn() (clook_add_request) 
και elevator_dispatch_fn() (clook_dispatch).
Πιο συγκεκριμένα, στην elevator_add_req_fn() (clook_add_request) προσθέσαμε κώδικα στον οποίο ελέγχεται η σειρά με την οποία εισέρχο-
νται νέα αιτήματα στην ήδη υπάρχουσα λίστα αιτημάτων, καθώς έχει μεγάλη σημασία για τον αλγόριθμο η ταξινόμηση
των αιτημάτων προς εξυπηρέτηση από την κεφαλή. Για αυτόν τον λόγο λαμβάνουμε υπόψη τη θέση της κεφαλής του δί-
σκου(hdd_head στον κώδικα μας), ώστε να είμαστε σίγουροι πως η νέα αίτηση θα τοποθετηθεί σωστά στη λίστα αιτη-
μάτων. Επιπλέον, έχουμε προσθέσει κατάλληλο printk που αφορά τις ενέργειες που γίνονται στις συγκεκριμένες τοπο-
θεσίες του δίσκου.
Στην elevator_dispatch_fn() (clook_dispatch) έχουμε προσθέσει κώδικα, ο οποίος εκτός του ότι αφαιρεί από τη λίστα αιτη-
μάτων το πρώτο στοιχείο, συγκρατεί στην μεταβλητή hdd_head την τρέχουσα τοποθεσία της κεφαλής.

Στον αλγόριθμο μας διακρίνουμε δύο περιπτώσεις διατρέχοντας τη λίστα αιτημάτων. Ο τομέας του εισερχόμενου αιτήματος
μπορεί να είναι μικρότερος του τρέχοντος τομέα της κεφαλής. Η δεύτερη περίπτωση είναι ο τομέας του αιτήματος να είναι
μεγαλύτερος ή ίσος εκείνου της κεφαλής. Αν ισχύει η πρώτη περίπτωση, το νέο αίτημα θα τοποθετηθεί στο πίσω(2ο) μέρος
της λίστας, στην κατάλληλη θέση ανάλογα με τον αριθμό του τομέα του. Στην αντίθετη περίπτωση, το νέο αίτημα πρόκειται
να εξυπηρετηθεί νωρίτερα και έτσι μπαίνει στο 1ο μισό της λίστας όπως αυτή νοητά χωρίζεται με σημείο αναφοράς τον
τομέα της κεφαλής.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Για να εξετάσουμε την ορθότητα του αλγορίθμου μας, χρησιμοποιήσαμε προγράμματα που γράψαμε οι ίδιοι, τα οποία
χρησιμοποιούσαν τον εικονικό δίσκο. Το read_test διαβάζει δεδομένα από ένα αρχείο, το read_write_test διαβάζει δεδομένα
από ένα αρχείο και τα γράφει σε ένα άλλο, ενώ το write_test γράφει δεδομένα σε ένα νέο αρχείο.
Για να λειτουργήσουν τα προγράμματα read_test(ανάγνωση δεδομένων) και read_write_test(ανάγνωση και εγγραφή δεδομένων),
πρέπει να έχει εκτελεστεί το πρόγραμμα write_test(εγγραφή δεδομένων), ώστε να έχει παραχθεί το input file.
Το μέγεθος των δεδομένων μπορεί να προσαρμοστεί με την αύξηση του αριθμού των επαναλήψεων του βρόχου for στο αρχείο write_test.c.
Επίσης, αξιολογήσαμε τον αλγόριθμο και με απλή δημιουργία τυχαίων αρχείων στον
εικονικό δίσκο χρησιμοποιώντας τις εντολές: sudo dd if=/dev/urandom of=output1 bs=1M count=50
                                       και  sudo dd if=/dev/urandom of=output2 bs=1M count=450
με τις οποίες δημιουργήσαμε τα τυχαία αρχεία.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Παρακάτω βλέπουμε ένα παράδειγμα εισαγωγής νέων αιτημάτων, απόρροια της δημιουργίας τυχαίου αρχείου στον εικο-
μας δίσκο. Παράλληλα έχουμε και τη δυνατότητα παρατήρησης της λίστας όπως αυτή διαμορφώνεται από τα αιτήματα καθώς
και την τρέχουσα θέση της κεφαλής:


[  671.415127] [CLOOK] add W 244799
[  671.415130] [CLOOK] add W 1835591


Στιγμιαία η λίστα νέων αιτημάτων και η θέση της κεφαλής είναι η ακόλουθη:

[  671.415125] ADD Request Queue: 237631  238655  239679  240703  241727  242751  243775
[  671.415125] ADD:hdd_head is at 526047
[  671.415128] ADD Request Queue: 237631  238655  239679  240703  241727  242751  243775  244799
[  671.415128] ADD:hdd_head is at 526047
[  671.415131] ADD Request Queue: 1835591  237631  238655  239679  240703  241727  242751  243775  244799
[  671.415131] ADD:hdd_head is at 526047

Βλέπουμε αρχικά λοιπόν πως η κεφαλή βρίσκεται στη θέση 526047. Εισέρχεται αίτημα για την 244799. Η τοποθεσία του αιτήματος
βρίσκεται σε μικρότερο τομέα από εκείνη της κεφαλής, επομένως το αίτημα τοποθετείται στο τέλος της λίστας. Στη συνέχεια όμως, εισέρ-
χεται αίτημα για την 1835591 που είναι σε αρκετά μεγαλύτερο τομέα από τη θέση της κεφαλής. Έτσι, πρέπει να εξυπηρετηθεί νωρίτερα
από τις ήδη υπάρχουσες αιτήσεις στη λίστα αιτημάτων και για αυτό τοποθετείται στην αρχή της λίστας. Όταν χρειαστεί αυτά τα
αιτήματα να εξυπηρετηθούν από την κεφαλή, πρώτα θα εξυπηρετηθεί (στο στιγμιότυπο του παραδείγματος και θεωρώντας πως θα γί-
νουν διαδοχικά dispatches χωρίς να διακοπούν από κάποια προσθήκη αιτήματος) το αίτημα με θέση 1835591, έπειτα εκείνο με
237631, στη συνέχεια εκείνο στη θέση 238655 κ.ο.κ.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Σε ένα επιπλέον παράδειγμα, αυτή τη φορά από πρόγραμμα που μόνο διαβάζει από ένα αρχείο στον εικονικό δίσκο βλέπουμε το παρακά-
τω αποτέλεσμα:

[  272.016128] [CLOOK] add R 1326487

Στιγμιαία η λίστα νέων αιτημάτων και η θέση της κεφαλής είναι η ακόλουθη:

[  272.016126] ADD Request Queue: 115407
[  272.016126] ADD:hdd_head is at 1326231
[  272.016129] ADD Request Queue: 1326487  115407

Όπως και προηγουμένως, καθώς η κεφαλή είναι στη θέση 1326231 και το νέο αίτημα δείχνει στην 1326487, τότε αυτό θα μπει σωστά
στην αρχή της λίστας.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Γενικά τα αιτήματα και η εξυπηρέτησή τους από την κεφαλή, μετά την εκτέλεση της εντολής dmesg έχουν την παρακάτω
μορφή:


[  671.415110] [CLOOK] add W 237631
[  671.415114] [CLOOK] add W 238655
[  671.415116] [CLOOK] add W 239679
[  671.415118] [CLOOK] add W 240703
[  671.415120] [CLOOK] add W 241727
[  671.415122] [CLOOK] add W 242751
[  671.415125] [CLOOK] add W 243775
[  671.415127] [CLOOK] add W 244799
[  671.415130] [CLOOK] add W 1835591
[  671.415134] [CLOOK] add W 1836615
[  671.415137] [CLOOK] add W 1837639
[  671.415141] [CLOOK] add W 1838663
[  671.415145] [CLOOK] add W 1839687
[  671.415148] [CLOOK] add W 1840711
[  671.415153] [CLOOK] add W 1841735
[  671.415157] [CLOOK] add W 1842759
[  671.415162] [CLOOK] dsp W 1835591
[  671.417756] [CLOOK] dsp W 1836615
[  671.419868] [CLOOK] dsp W 1837639
[  671.420039] [CLOOK] dsp W 1838663
[  671.422503] [CLOOK] dsp W 1839687
[  671.424850] [CLOOK] dsp W 1840711
[  671.427327] [CLOOK] dsp W 1841735
[  671.429522] [CLOOK] dsp W 1842759
[  671.431445] [CLOOK] dsp W 237631
[  671.433682] [CLOOK] dsp W 238655
[  671.435809] [CLOOK] dsp W 239679
[  671.438314] [CLOOK] dsp W 240703
[  671.440700] [CLOOK] dsp W 241727
[  671.442993] [CLOOK] dsp W 242751
[  671.445315] [CLOOK] dsp W 243775
[  671.447522] [CLOOK] dsp W 244799

Αρχικά η κεφαλή του δίσκου βρίσκεται στον τομέα 526047. Βρίσκεται λοιπόν σε μεγαλύτερο τομέα από τις πρώτες επτά προσθήκες αιτημάτων στη
λίστα και μικρότερο από τις επόμενες οκτώ. Παρατηρούμε λοιπόν πως προστίθενται αιτήματα τόσο μεγαλύτερων από τη θέση της κεφαλής τομέων
όσο και μικρότερων. Η κεφαλή θα εξυπηρετήσει αρχικά με αύξουσα σειρά αριθμού τομέα τις αιτήσεις που αναφέρονται σε τομείς μεγαλύτερους
από τον δικό της και αφού εξυπηρετήσει και την αίτηση με το μεγαλύτερο αριθμό τομέα θα συνεχίσει εξυπηρετώντας αρχικά εκείνην την αίτηση
με τον μικρότερο τομέα, και στη συνέχεια τους υπόλοιπους με αύξουσα σειρά αριθμού τομέα, όπως δηλαδή θα έπρεπε σύμφωνα με τον αλγόριθμο C-LOOK.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Παρατηρούμε πως αντιπροσωπευτικά αποτελέσματα, όσον αφορά τα reads, από τα προγράμματά μας έχουμε μόνο την πρώτη φορά που τα εκτελούμε.
Αυτό συμβαίνει λόγω του caching. Έτσι, παρατηρούμε πολύ λιγότερα έως και μηδαμινά reads συγκριτικά με τα συνολικά writes των προγραμμάτων
μας στο δίσκο, διότι τα δεδομένα διαβάζονται κατευθείαν από την cache. Με τα writes δεν είναι τόσο έντονο το πρόβλημα καθώς εν τέλει θα
γραφούν στο δίσκο.

