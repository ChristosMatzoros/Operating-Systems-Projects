Παππάς Απόστολος 2109 apopappas@inf.uth.gr
Ματζώρος Χρήστος Κωνσταντίνος 2169 cmatzoros@inf.uth.gr
Γιαννούκος Τριαντάφυλλος Ανάργυρος 2232 tgiannoukos@inf.uth.gr

Λίγα λόγια για τον αλγόριθμο Shortest Job First.
	Ο αλγόριθμος Shortest Job First είναι αλγόριθμος που χρησιμοποιείται για τη χρονοδρομολόγηση
	των διεργασιών που πρόκειται να τρέξουν στον επεξεργαστή. Ιδεατά επιλέγει από τις ήδη
	έτοιμες διεργασίες, εκείνη που έχει τον λιγότερο εναπομείναντα χρόνο εκτέλεσης. Κάτι τέτοιο
	όμως δεν είναι στην πραγματικότητα εφικτό. Για αυτό ο SJF λαμβάνει γενικά υπόψη τη διάρκεια
	του ξεσπάσματος κάθε διεργασίας στον επεξεργαστή ώστε να επιλέξει την κατάλληλη διεργασία για
	να τρέξει. Ως ξέσπασμα ορίζεται ο χρόνος από τη στιγμή που μια διεργασία λαμβάνει τον έλεγχο
	του επεξεργαστή έως ότου τον αφήσει για οποιονδήποτε λόγο. Σημειώνεται πως ο αλγόριθμος
	μπορεί να είναι preemptive ή non-preemptive ανάλογα με την υλοποίηση του.

	Καταλήγουμε στο συμπέρασμα λοιπόν πως, εξ´ορισμού του, ο SJF διαθέτει ορισμένες αδυναμίες οι
	οποίες έχουν ως συνέπεια την λιμοκτονία κάποιων διεργασιών σε ορισμένες περιπτώσεις. Για παράδειγμα,
	εαν έχουμε μια μεγάλη στην ολοκλήρωση υπολογιστική διεργασία και, καθώς ξεκινήσει να εκτελείται,
	"έρθουν" πολλές πολύ μικρότερες διεργασίες ταυτόχρονα, τότε η υπολογιστική διεργασία θα λιμοκτονήσει.

	Επιπλέον, αναφέρθηκε προηγουμένως πως δεν είναι στην πραγματικότητα εφικτό να είναι γνωστός ο
	εναπομείναντας χρόνος εκτέλεσης κάποιας διεργασίας. Αυτό το μειονέκτημα μπορεί να περιοριστεί σε
	κάποιο βαθμό με τη χρήση του ξεσπάσματος των διεργασιών καθώς και με το χρόνο που οι διεργασίες
	περιμένουν στην ουρά για να εκτελεστούν.Έτσι έχουμε δύο παραλλαγές του αλγόριθμου,
	τον SJF με Expected Burst και τον SJF με Goodness.


SJF με Expected Burst:
	Αρχικά οι καινούριες διεργασίες που δημιουργούνται έχουν μηδενικό Exp_Burst,
	άρα προτιμούνται από οποιαδήποτε παλαιότερη, και εκτελούνται αμέσως.
	Επίσης γενικά διεργασίες Ε/Ε προτιμούνται από μεγάλες υπολογιστικές διεργασίες,
	καθώς έχουν μικρότερο χρόνο ξεσπάσματος.
	Έτσι, σε περίπτωση που νέες διεργασίες φτάνουν συνεχώς, ή τρέχουν αρκετές διεργασίες Ε/Ε,
	μεγάλες υπολογιστικές διεργασίες που ενδέχεται να τρέχουν θα παίρνουν μικρό
	μερίδιο του επεξεργαστή, κάτι που σε μια ακραία περίπτωση μπορεί να
	οδηγήσει στη λιμοκτονία τους.


SJF με Goodness:
	Σε μια προσπάθεια επίλυσης του προβλήματος λιμοκτονίας στον προηγούμενο αλγόριθμο,
	η χρονοδρομολόγηση SJF με Goodness συμπεριλαμβάνει εκτός του χρόνου ξεσπάσματος της διεργασίας,
	το χρόνο που μια διεργασία περιμένει στην ουρά των έτοιμων διεργασιών.
	Λόγω της μορφής του μαθηματικού τύπου με τον οποίο γίνεται ο υπολογισμός του Goodness,
	oι διεργασίες που δημιουργούνται έχουν μεγάλη τιμή Goodness,
	καθώς οι τιμές των Expected Burst και ο χρόνος που περιμένουν στην ουρά είναι 0.
	Επομένως, αντίθετα με τη δρομολόγηση με Expected Burst, μία νέα διεργασία δε θα εκτελεστεί
	αντί μιας άλλης που περιμένει, ακόμη κι αν αυτή απαιτεί περισσότερο χρόνο του επεξεργαστή.
	Κάτι αντίστοιχο συμβαίνει και με τις διεργασίες αφού τρέχουν, καθώς η τιμή του goodness
	είναι μεγαλύτερη από αυτές άλλων διεργασιών που περιμένουν για να τρέξουν.


Παρατηρήσεις από την εκτέλεση του αλγορίθμου με τα profiles που δημιουργήσαμε

	starvation.conf:
		Η αδυναμία του SJF όσον αφορά την περίπτωση που δεν λαμβάνεται υπόψη ο χρόνος παραμονής μιας
		διεργασίας στη ready queue, φαίνεται κατά την εκτέλεση του profile (starvation). Στο συγκεκριμένο
		παράδειγμα, η διεργασία που ξεκινάει πρώτη την εκτέλεσή της, δεν προλαβαίνει να τελειώσει πριν
		ολοκληρωθεί το κβάντο. Στη συνέχεια καταφθάνουν νέες διεργασίες που είναι έτοιμες προς εκτέλεση συνεχόμενα,
		με σταθερό ρυθμό(καθε 10 ms) και ίδιο φόρτο εργασίας(workduration 11ms).

		-Εάν κάνουμε χρήση του expected burst έναντι του goodness, παρατηρούμε ότι οι διεργασίες που φτάνουν
		επιλέγονται από τον αλγόριθμο για εκτέλεση και παίρνουν χρόνο από τον επεξεργαστή. Στη συνέχεια, παρατηρούμε πως
		ανάμεσα στις διεργασίες που παραμένουν στην ready queue και έχουν το ίδιο expected burst, δεν επιλέγεται αυτή
		που περίμενε περισσότερο(δηλαδή η starvation), αλλά οι υπόλοιπες λόγω υλοποίησης, αφού δεν λαμβάνουμε υπόψη τον
		χρόνο που περίμενε στην ready queue. Ενδεικτικά, ο μέσος χρόνος εκτέλεσης είναι περίπου 12,5ms και ο μέσος χρόνος
		διεκπεραίωσης είναι περίπου 240ms. Οπότε ο μέσος χρόνος απόκρισης ισούται με 227ms.

		-Εάν κάνουμε χρήση του goodness παρατηρούμε πως ο μέσος χρόνος διεκπεραίωσης βελτιώνεται κατά πολύ αφού πλέον επιλέγονται
		οι διεργασίες λαμβάνοντας υπόψη και τον χρόνο που αυτές περιμένουν στην ready queue.Ενδεικτικά, ο μέσος χρόνος εκτέλεσης
		είναι περίπου 12,5ms και ο μέσος χρόνος διεκπεραίωσης είναι περίπου 32ms. Οπότε ο μέσος χρόνος απόκρισης
		ισούται περίπου με 19,5ms.

		Αν και ο μέσος χρόνος εκτέλεσης είναι ίδιος και στις δυο περιπτώσεις, ο μέσος χρόνος διεκπεραίωσης είναι πολύ μεγαλύτερος
		όταν δεν λαμβάνουμε υπόψη το goodness της διεργασίας, που τελικά επηρεάζει σημαντικά τον τελικό χρόνο απόκρισης.

	noninteractive.conf:
		Στην υλοποίηση με Goodness στις περισσότερες περιπτώσεις μια διεργασία δεν τρέχει
		συνεχόμενα για περισσότερες από 1 φορές, εφόσον δεν είναι μόνη της στο runqueue.
		Οπότε, παρατηρούμε ότι συμπεριφέρεται σαν Round Robin στη συγκεκριμένη περίπτωση
		που έχουμε μόνο non interactive διεργασίες, καθώς αυτές χρησιμοποιούν
		όλο το διαθέσιμο κομμάτι του επεξεργαστή κάθε φορά που τρέχουν.

		
*Για χρήση του αλγορίθμου SJF με Exp_Burst βάλτε σε σχόλια τη γραμμή 153
